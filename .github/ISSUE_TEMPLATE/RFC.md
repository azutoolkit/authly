# RFC Authorization Code With PKCE (Proof Key for Code Exchange)

**Feature Name:** Authorization Code With PKCE (Proof Key for Code Exchange)

**Type:** Enhancement

**Related components:** Authorization Code Grant

## Summary

The Proof Key for Code Exchange (PKCE, pronounced pixie) extension describes a technique for public clients to mitigate the threat of having the authorization code intercepted. The technique involves the client first creating a secret, and then using that secret again when exchanging the authorization code for an access token. This way if the code is intercepted, it will not be useful since the token request relies on the initial secret.

## Motivation

- OAuth 2.0 public clients utilizing the Authorization Code Grant are susceptible to the authorization code interception attack.
- Authly is missing the PKCE extension
- PKCE has been requested See Issue https://github.com/eliasjpr/authly/issues/5

## Detailed design

### Step 1 - Client Generates Code Verifier

When the native app begins the authorization request, instead of immediately launching a browser, the client first creates what is known as a “code verifier“. This is a cryptographically random string using the characters A-Z, a-z, 0-9, and the punctuation characters -._~ (hyphen, period, underscore, and tilde), between 43 and 128 characters long.

Create a code_verifier, which is a cryptographically-random key that will eventually be sent to Auth0 to request tokens. 

```javascript 
// Dependency: Node.js crypto module
// https://nodejs.org/api/crypto.html#crypto_crypto
function base64URLEncode(str) {
    return str.toString('base64')
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=/g, '');
}
var code_verifier = base64URLEncode(crypto.randomBytes(32));
```

### Setp 2 - Client Generates Code Challenge 

Once the app has generated the code verifier, it uses that to create the code challenge. For devices that can perform a SHA256 hash, the code challenge is a BASE64-URL-encoded string of the SHA256 hash of the code verifier. Clients that do not have the ability to perform a SHA256 hash are permitted to use the plain code verifier string as the challenge.

Generate a code_challenge from the code_verifier that will be sent to Auth0 to request an authorization_code.

```javascript
// Dependency: Node.js crypto module
// https://nodejs.org/api/crypto.html#crypto_crypto
function sha256(buffer) {
    return crypto.createHash('sha256').update(buffer).digest();
}
var challenge = base64URLEncode(sha256(verifier));

```

### Step 3 - Authorize the User

Now that the client has a code challenge string, it includes that and a parameter that indicates which method was used to generate the challenge (plain or S256) along with the standard parameters of the authorization request. This means a complete authorization request will include the following parameters.

- `response_type=code` – indicates that your server expects to receive an authorization code
- `client_id=` – The client ID you received when you first created the application
- `redirect_uri=` – Indicates the URL to return the user to after authorization is complete, such as org.example.app://redirect
- `state=1234zyx` – A random string generated by your application, which you’ll verify later
- `code_challenge=XXXXXXXXX` – The code challenge generated as previously described
- `code_challenge_method=S256` – either plain or S256, depending on whether the challenge is the plain verifier string or the SHA256 hash of the string. If this parameter is omitted, the server will assume plain.

```html
<a href="https://YOUR_DOMAIN/authorize?
  response_type=code&
  client_id=YOUR_CLIENT_ID&
  code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM&
  code_challenge_method=S256&
  redirect_uri=YOUR_CALLBACK_URL&
  scope=appointments%20contacts&
  audience=appointments:api&
  state=xyzABC123">
  Sign In
</a>
```

### Step 4 - Authorization Response

The authorization server should recognize the `code_challenge` parameter in the request, and associate that with the authorization code it generates. Either store this in the database along with the authorization code, or if you’re using self-encoded authorization codes then it can be included in the code itself. (See The Authorization Response for details.) The server returns the authorization code as normal, and does not include the challenge in the data returned.

### Step 5 - Authorization Code Exchange 

The native app will then exchange the authorization code for an access token. In addition to the parameters defined in Authorization Code Request, the client will also send the code_verifier parameter. A complete access token request will include the following parameters:

    - `grant_type=authorization_code` – Indicates the grant type of this token request
    - `code` – The client will send the authorization code it obtained in the redirect
    - `redirect_uri` – The redirect URL that was used in the initial authorization request
    - `client_id` – The application’s registered client ID
    - `code_verifier` – The code verifier for the PKCE request, that the app originally generated before the authorization request.

In addition to validating the standard parameters, the authorization server will also validate the code_verifier in the request. Since the code_challenge and code_challenge_method were associated with the authorization code initially, the server should already know which method (plain or SHA256) to use to verify the code_verifier.

If the method is plain, then the authorization server needs only to check that the provided code_verifier matches the expected code_challenge string.

If the method is S256, then the authorization server should take the provided code_verifier and transform it using the same method the client will have used initially. This means calculating the SHA256 hash of the verifier and base64-url-encoding it, then comparing it to the stored code_challenge string.

If the verifier matches the expected value, then the server can continue on as normal, issuing an access token and responding appropriately. If there is a problem, then the server responds with an invalid_grant error.

### Errors Responses

The authorization server can require that public clients must use the PKCE extension. This is really the only way to allow public clients to have a secure authorization flow without using the client secret. Since the authorization server should know that a specific client ID corresponds to a public client, it can deny authorization requests for public clients that do not contain a code challenge.

If the authorization server requires public clients to use PKCE, and the authorization request is missing the code challenge, then the server should return the error response with error=invalid_request and the error_description or error_uri should explain the nature of the error.

